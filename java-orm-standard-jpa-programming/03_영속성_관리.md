# Chapter 3: 영속성 관리

<br>

### 엔티티 매니저

- 엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 `엔티티와 관련된 모든 일을 처리`한다
  - 이름 그대로 엔티티 관리자다
- 개발자 입장에서 엔티티 매니저는 엔티티를 저장하는 가상의 데이터베이스로 생각하면 된다

## 1. 엔티티 매니저 팩토리와 엔티티 매니저

- `엔티티 매니저 팩토리`
  - 엔티티 매니저를 만드는 공장
    - 공장을 만드는 `비용`은 상당히 `크다`
  - 한 개만 만들어서 애플리케이션 전체에 공유하도록 설계되어 있다
    - 여러 thread가 동시에 접근해도 안전하므로 서로 다른 thread 간에 공유해도 된다
- `엔티티 매니저`
  - 공장에서 엔티티 매니저를 생성하는 `비용`은 거의 `들지 않는다`
  - 여러 thread가 동시에 접근하면 `동시성 문제` 가 발생하므로 thread간에 공유하면 안 된다
  - 데이터베이스 연결이 꼭 필요한 시점까지 `커넥션을 얻지 않는다`
    - 보통 트랜잭션을 시작할 때 커넥션을 획득한다

## 2. 영속성 컨텍스트란?

- `영속성 컨텍스트`란 엔티티를 `영구 저장`하는 환경이다
- 엔티티 매니저로 엔티티를 저장하거나 조회하면, 엔티티 매니저는 `영속성 컨텍스트`에 엔티티를 `보관`하고 `관리`한다

    ```java
    em.persist(member);
    ```

  - persist() method는 `엔티티 매니저`를 사용해서 회원 엔티티를 `영속성 컨텍스트`에 `저장`한다
- 영속성 컨텍스트는 `엔티티 매니저를 생성`할 때 `하나` 만들어진다
- 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있고, 영속성 컨텍스트를 관리할 수 있다

## 3. 엔티티의 생명 주기

엔티티에는 4가지 상태가 존재한다

- `비영속 (new/transient)`
  - 영속성 컨텍스트와 전혀 `관계가 없는` 상태
  - 엔티티 객체를 생성한 상태이며 아직 저장하지 않은 상태
    - 영속성 컨텍스트나 데이터베이스와는 전혀 관련이 없다
  - ex)

    ```java
    Member member = new Member();
    member.setId("member1);
    member.setUserName("회원1");
    ```

- `영속 (managed)`
  - 영속성 컨텍스트에 `저장`된 상태
  - 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태
    - 이렇게 `영속성 컨텍스트가 관리`하는 엔티티를 영속 상태라 한다
  - ex)

      ```java
      em.persist(member);
      ```

  - `em.find()` 나 `JPQL` 을 사용해서 `조회한 엔티티`도 영속성 컨텍스트가 관리하는 영속 상태다
- `준영속(detached)`
  - 영속성 컨텍스트에 `저장되었다가 분리`된 상태
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 `영속성 컨텍스트가 관리하지 않으면` 준영속 상태가 된다
  - 준영속 상태로 만들기 위한 방법
    - `em.detach()`
      - 특정 엔티티만 준영속 상태로 만든다
    - `em.close()`
      - 영속성 컨텍스트를 닫는다
    - `em.clear()`
      - 영속성 컨텍스트의 데이터를 비운다
- `삭제(removed)`
  - 삭제된 상태
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다
  - ex)

    ```java
    em.remove(member);
    ```

## 4. 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값**
  - 영속성 컨텍스트는 엔티티를 `식별자 값`(@Id로 테이블의 기본 키와 매핑한 값)으로 `구분`한다
  - 따라서 영속 상태는 식별자 값이 반드시 있어야 한다
- **영속성 컨텍스트와 데이터베이스 저장**
  - 보통 `트랜잭션` 을 `커밋` 하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 `반영`하는데, 이것을 `플러시(flush)`라 한다
- **영속성 컨텍스트 관리 장점**
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 4-1. 엔티티 조회

- 영속성 컨텍스트는 `내부에 캐시`를 가지고 있는데 이것을 `1차 캐시`라 한다
- 영속성 컨텍스트 내부에 Map이 하나 있는데 `키`는 `@Id로 매핑한 식별자`고 `값`은 `엔티티 인스턴스`다
- 1차 캐시의 키는 식별자 값이고, 식별자 값은 데이터베이스 기본 키와 매핑되어 있다
  - 영속성 컨텍스트에 데이터를 저잔하고 조회하는 모든 기준은 데이터베이스 `기본 키 값` 이다
- `동작 순서`
    1. em.find(Member.class, "member1")를 실행한다
    2. 1차 캐시에서 식별자 값으로 엔티티를 찾는다
    3. member1가 1차 캐시에 없으므로 데이터베이스에서 조회한다
    4. 조회한 데이터로 member1 엔티티를 생성해서 1차 캐시에 저장한다
    5. 조회한 엔티티를 반환한다
- 1차 캐시에 저장되어 있는 엔티티를 조회하면 메모리에 있는 1차 캐시에서 바로 불러오기 때문에 `성능상 이점` 을 누릴 수 있다
- `영속 엔티티의 동일성 보장`

  ```java
  Member a = em.find(Member.class, "member1");
  Member b = em.find(Member.class, "member1");
  
  System.out.println(a == b) // 동일성 보장
  ```

  - "em.find(Member.class, "member1")"를 반복해서 호출해도 영속성 컨텍스트는 `1차 캐시`에 있는 같은 엔티티 인스턴스를 반환하므로, 영속성 컨텍스트는 `성능상 이점`과 `엔티티의 동일성` 을 보장한다
  - JPA는 1차 캐시를 통해 `반복 가능한 읽기 (REPEATABLE READ)` 등급의 `트랜잭션 격리 수준`을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점이 있다

### 4-2. 엔티티 등록

- 엔티티 매니저는 `트랜잭션`을 `커밋`하기 직전까지 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT SQL을 모아둔다
  - 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보낸다
  - 이를 `트랜잭션을 지원`하는 `쓰기 지연` (transactional write-behind)이라 한다
- `동작 과정`
  - 영속성 컨텍스트는 `1차 캐시`에 엔티티를 `저장`하면서, 동시에 엔티티 정보로 `등록 쿼리`를 만든다
  - 만들어진 등록 쿼리를 `쓰기 지연 SQL 저장소`에 보관한다
  - 트랜잭션을 커밋한다
- 트랜잭션을 `커밋`하면 엔티티 매니저는 우선 영속성 컨텍스트를 `플러시`한다
  - `플러시`는 영속성 컨텍스트의 `변경 내용`을 데이터베이스에 `동기화`하는 작업인데, 이때 등록, 수정, 삭제한 엔티티를 데이터베이스에 `반영`한다
    - == 쓰기 지연 SQL 저장소에 모인 쿼리를 데이터베이스에 보낸다!
    - 이렇게 영속성 컨텍스트의 변경 내용을 데이터베이스에 `동기화` 한 후에 실제 데이터베이스 트랜잭션을 `커밋` 한다
- `트랜잭션을 지원하는 쓰기 지연이 가능한 이유`
  - 등록 쿼리를 그때 그때 데이터베이스에 전달해도, `트랜잭션`을 `커밋`하지 않으면 아무 소용이 없다
  - 어떻게든 `커밋 직전`에만 데이터베이스에 SQL을 전달하면 된다
  - 이것이 트랜잭션을 지원하는 쓰기 지연이 가능한 이유다!
- 이 기능을 잘 활용하면 `모아둔 등록 쿼리`를 데이터베이스에 `한 번에 전달`해서 성능을 최적화할 수 있다

### 4-3. 엔티티 수정

- SQL 수정 쿼리의 문제점
  - SQL을 사용하면 수정 쿼리를 직접 작성해야 한다
  - 비즈니스 로직이 바뀔 때마다 수정 쿼리를 추가/변경해야 하므로,
    - 수정 쿼리가 많아지고,
    - 비즈니스 로직을 분석하기 위해 SQL을 계속 확인해야 한다
  - 비즈니스 로직이 SQL에 의존하게 된다
- `변경 감지 (dirty checking)`
  - JPA는 `변경 감지` 를 통해 엔티티를 수정한다

    ```java
    EntityManager em = emf.createEntityManager();
    EntityTransaction transaction = em.getTransaction();
    transaction.begin(); 
    
    Member memberA = em.find(Member.class, "memberA");
    
    memberA.setUsername("hi");
    memberA.setAge(10);
    
    transaction.commit();
    ```

    - 위의 코드를 실행하면 데이터베이스까지 반영이 되어 데이터가 변경된 걸 확인할 수 있다
    - 위와 같이 엔티티의 `변경사항`을 데이터베이스에 `자동으로 반영`하는 기능을 `변경 감지`라 한다
  - JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해두는데 이것을 `스냅샷` 이라고 한다
    - 그리고 `플러시 시점`에 `스냅샷`과 `엔티티`를 비교해서 변경된 엔티티를 찾는다
  - `변경 감지 동작 순서`
        1. 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 `플러시`가 호출된다
        2. 엔티티와 스냅샷을 `비교`해서 변경된 엔티티를 찾는다
        3. 변경된 엔티티가 있으면, `수정 쿼리`를 생성해서 `쓰기 지연 SQL 저장소`에 보낸다
        4. 쓰기 지연 저장소의 SQL을 `데이터베이스에 보낸다`
        5. 데이터베이스 `트랜잭션`을 `커밋`한다
  - 변경 감지는 영속성 컨텍스트가 관리하는 `영속 상태의 엔티티`에만 적용된다
  - JPA는 변경감지가 일어나면 엔티티의 `모든 필드를 업데이트`한다 (JPA의 기본 전략!)
    - `장점`
      - 모든 필드를 수정하면 `수정 쿼리`가 항상 `같다`
        - 따라서 애플리케이션 로딩 시점에 수정 쿼리를 `미리 생성`해두고 `재사용`할 수 있다
      - 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한 번 `파싱된 쿼리`를 `재사용`할 수 있다
    - `단점`
      - 데이터베이스에 보내는 데이터 `전송량`이 `증가`한다
  - 필드가 많거나 저장되는 내용이 너무 크면, 수정된 데이터만 사용해서 `동적으로 UPDATE SQL을 생성`하는 전략을 선택하면 된다
    - 이때는 하이버네이트 확장 기능을 사용해야 한다
      - ex)

        ```java
        @Entity
        @org.hibernate.annotations.DynamicUpdate
        @Table(name = "Member")
        public class Member {...}
        ```

    - `@DynamicUpdate` 어노테이션을 사용하면 수정된 데이터만 사용해서 동적으로 UPDATE SQL을 생성한다
      - 데이터를 저장할 때 데이터가 존재하는 (null이 아닌) 필드만으로 INSERT SQL을 동적으로 생성하는 `@DynamicInsert` 도 있다
    - 상황에 따라 다르지만, 컬럼이 대략 30개 이상이 되면 기본 방법인 `정적 수정 쿼리` 보다 `@DynamicUpdate` 를 사용한 `동적 수정 쿼리` 가 빠르다고 한다
      - but, 이렇게 한 테이블에 컬럼이 30개 이상 된다는 것은 테이블 설계상 `책임` 이 적절히 분리되지 않았을 가능성이 높다

### 4-4. 엔티티 삭제

- 엔티티를 `삭제`하려면 먼저 삭제 대상 엔티티를 `조회`해야 한다
- `em.remove()` 에 삭제 대상 엔티티를 넘겨주면 엔티티를 삭제한다
  - 엔티티를 즉시 삭제하는 것이 아니라, 엔티티 등록과 비슷하게 `삭제 쿼리` 를 `쓰기 지연 SQL 저장소` 에 등록한다
  - 이후 트랜잭션을 커밋해서 플러시를 호출하면 실제 데이터베이스에 삭제 쿼리를 전달한다
- `em.remove()` 를 호출하는 순간 해당 전달된 엔티티는 `영속성 컨텍스트` 에서 `제거` 된다
  - 삭제된 엔티티는 재사용 하지 말고, 자연스럽게 GC의 대상이 되도록 두는 것이 좋다

## 5. 플러시

플러시는 영속성 컨텍스트의 `변경 내용`을 데이터베이스에 `반영` (`동기화`) 한다

1. `변경 감지`가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 `스냅샷과 비교`해서 `수정된 엔티티`를 찾는다
    1. 수정된 엔티티는 `수정 쿼리`를 만들어 `쓰기 지연 SQL 저장소`에 `등록`한다
2. 쓰기 지연 SQL 저장소의 쿼리를 `데이터베이스`에 `전송`한다

### 영속성 컨텍스트를 플러시하는 3가지 방법

1. `em.flush()`를 `직접 호출`한다
    - 테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용 X
2. `트랜잭션 커밋` 시 플러시가 `자동 호출`된다
    - 데이터베이스에 변경 내용을 SQL로 전달하지 않고, 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다
    - 트랜잭션을 커밋하기 전에 `플러시`를 `호출`해서 영속성 컨텍스트의 변경 내용을 데이터베이스에 `반영` 한다
    - JPA는 트랜잭션을 커밋할 때 플러시를 자동으로 호출한다
3. `JPQL 쿼리 실행` 시 플러시가 `자동 호출`된다

    ```java
    em.persist(memberA); 
    em.persist(memberB); 
    em.persist(memberC);
    // 중간에 JPQL 실행 
    query = em.createQuery("select m from Member m", member.class); 
    List<Member> members = query.getResultList();
    ```

      - em.persist()를 호출해서 엔티티들을 영속 상태로 만든 후에, JPQL을 실행하면 JPQL은 SQL로 변환되어 데이터베이스에서 엔티티를 조회하면 영속성 컨텍스트에 저장된 데이터가 조회된다
        - 이는 JPQL을 실행할 때도 플러시를 자동 호출하기 때문에 가능하다

### 플러시 모드 옵션

- 엔티티 매니저에 플러시 모드를 직접 지정하려면 `javax.persistence.FlushModeType` 을 사용하면 된다
  - `FlushModeType.AUTO`
    - 커밋이나 쿼리를 실행할 때 플러시
    - default 값이다
  - `FlushModeType.COMMIT`
    - 커밋할 때만 플러시

### 플러시 주의 사항

- 플러시라는 이름으로 인해 영속성 컨텍스트에 보관된 엔티티를 지운다고 생각하면 안 된다
  - 영속성 컨텍스트의 `변경 내용` 을 데이터베이스에 `동기화` 하는 것이 플러시다
- 그리고 데이터베이스와 동기화를 최대한 늦추는 것이 가능한 이유는 `트랜잭션` 이라는 `작업 단위` 가 있기 때문이다
  - `트랜잭션 커밋 직전`에만 변경 내용을 데이터베이스에 보내 `동기화` 하면 된다

## 6. 준영속

- 영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 `분리` 된 것을 `준영속 상태` 라 한다
  - 즉, 영속 상태였다가 더는 영속성 컨텍스트가 관리하지 않는 상태를 뜻한다
  - 따라서 준영속 상태의 엔티티는 `영속성 컨텍스트가 제공하는 기능` 을 사용할 수 없다
- 영속성 상태의 엔티티를 준영속 상태로 만드는 방법
    1. `em.detach(entity)`
        - 특정 엔티티만 준영속 상태로 전환한다
        - 해당 method를 호출하는 순간 `1차 캐시` 부터 `쓰기 지연 SQL 저장소` 까지 해당 엔티티를 관리하기 위한 모든 정보가 제거된다
    2. `em.clear()`
        - 영속성 컨텍스트를 완전히 `초기화`해서 `모든 엔티티`를 `준영속 상태`로 만든다
    3. `em.close`
        - 영속성 컨텍스트를 종료하면 해당 영속성 컨텍스트가 관리하던 영속 상태의 엔티티가 모두 준영속 상태가 된다
- 영속 상태의 엔티티는 주로 영속성 컨텍스트가 종료되면서 준영속 상태가 된다
  - 개발자가 직접 준영속 상태로 만드는일은 드물다

### 준영속 상태의 특징

- 거의 `비영속 상태에 가깝다`
  - 영속성 컨텍스트가 관리하지 않으므로 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공하는 어떤한 기능도 동작하지 않는다
- `식별자 값`을 가지고 있다
  - 비영속 상태는 식별자 값이 없을 수도 있지만, 준영속 상태는 이미 한 번 영속 상태였으므로 반드시 식별자 값을 가지고 있다
- `지연 로딩`을 할 수 없다
  - 지연 로딩(LAZY LOADING)은 실제 객체 대신 `프록시 객체`를 로딩해두고, 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법이다
  - but, 준영속 상태는 영속성 컨텍스트가 더는 관리하지 않으므로 지연 로딩 시 문제가 발생한다

### 병합으로 영속 상태로 변경하기

- `준영속` 상태의 엔티티를 다시 영속 상태로 변경하려면 병합을 사용하면 된다
  - `merge()` method는 준영속 상태의 엔티티를 받아서 그 정보로 `새로운 영속 상태의 엔티티를 반환` 한다
    - 파라미터로 넘어온 엔티티는 병합 후에도 준영속 상태로 남아있다!
- `비영속` 엔티티도 `병합` 을 이용해서 `영속 상태` 로 만들 수 있다
  - 병합은 파라미터로 넘어온 식별자 값으로 영속성 컨텍스트를 `조회`하고,
  - 찾는 엔티티가 없으면 데이터베이스에서 조회한다
    - 만약 데이터베이스에서도 발견하지 못하면 `새로운 엔티티` 를 생성해서 병합한다
- 병합은 준영속, 비영속을 신경 쓰지 않는다
  - 식별자 값으로 엔티티를 조회할 수 있으면 불러서 병합하고, 없으면 새로 생성해서 병합한다
  - 따라서 병합은 `save or update` 기능을 수행한다

## 7. 정리

- `엔티티 매니저` 는 `엔티티 매니저 팩토리` 에 생성한다
  - 자바를 직접 다루는 J2SE 환경에서는 엔티티 매니저를 만들면 그 내부에 `영속성 컨텍스트` 도 함께 만들어진다
  - 이 영속성 컨텍스트는 `엔티티 매니저` 를 통해서 접근할 수 있다
- 영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 `객체를 보관` 하는 가상의 데이터베이스 같은 역할을 한다
  - 영속성 컨텍스트 덕분에 `1차 캐시`, `동일성 보장`, `트랜잭션을 지원하는 쓰기 지연`, `변경 감지`, `지연 로딩` 기능을 사용할 수 있다
- 영속성 컨텍스트에 저장한 엔티티는 `플러시 시점` 에 데이터베이스에 `반영` 되는데, 일반적으로 `트랜잭션` 을 `커밋` 할 때 영속성 컨텍스트가 플러시된다
- 영속성 컨텍스트가 관리하는 엔티티를 `영속 상태의 엔티티` 라고 하는데, 영속성 컨텍스트가 해당 엔티티를 더 이상 관리하지 못하면 그 엔티티는 `준영속 상태의 엔티티` 라고 한다
  - 준영속 상태의 엔티티는 더는 영속성 컨텍스트의 관리를 받지 못하므로, 영속성 컨텍스트가 지원하는 기능을 사용할 수 없다
