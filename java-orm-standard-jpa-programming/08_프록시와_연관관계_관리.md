# Chapter 8: 프록시와 연관관계 관리

<br>

## 1. 프록시

- 엔티티를 조회할 때 연관된 엔티티들이 항상 사용되는 것은 아니다
- JPA는 이런 문제를 해결하려고 엔티티가 실제 사용될 때까지 데이터베이스 조회를 지연하는 방법을 제공하는데, 이것을 `지연 로딩` 이라 한다
  - 엔티티의 값을 실제 사용하는 시점에 데이터베이스에서 필요한 데이터를 조회하는 것이다
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데, 이것을 `프록시 객체` 라 한다

### 1-1. 프록시 기초

- JPA에서 식별자로 엔티티 하나를 조회할 때는 `EntityManager.find()` 를 사용한다
  - 이 method는 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회한다
  - 이렇게 엔티티를 직접 조회하면 엔티티를 실제 사용하든 사용하지 않든 데이터베이스를 조회하게 된다
- 엔티티를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 `EntityManager.getReference()` method를 사용하면 된다
  - 이 method를 호출할 때 JPA는 데이터베이스를 조회하지 않고, 실제 엔티티 객체도 생성하지 않는다
  - 대신에 `데이터베이스 접근`을 `위임`한 `프록시 객체`를 반환한다
- `프록시의 특징`
  - 프록시 클래스는 실제 클래스를 상속 받아 만들어지므로 실제 클래스와 겉 모양이 같다
    - 따라서 사용하는 입장에서는 이것이 진짜 객체인지 구분하지 않고 사용하면 된다
  - 프록시 객체는 실제 객체에 대한 `참조 (target)` 을 보관한다
  - 프록시 객체의 method를 호출하면 프록시 객체는 실제 객체의 method를 호출한다
- `프록시 객체의 초기화`
  - 프록시 객체는 member.getName() 처럼 `실제 사용`될 때 `데이터베이스를 조회`해서 `실제 엔티티 객체를 생성`하는데, 이것을 `프록시 객체의 초기화` 라고 한다
  - ex)
        1. getName()
            - 프록시 객체에 member.getName() 을 호출해서 실제 데이터를 조회한다
        2. 초기화 요청
            - 프록시 객체는 실제 엔티티가 생성되어 있지 않으면, 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 `초기화` 라고 한다
        3. DB 조회
            - 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성한다
        4. 실제 엔티티 생성 및 참조 보관
            - 프록시 객체는 생성된 실제 엔티티 객체의 참조를 Member target 멤버 변수에 보관한다
        5. target.getName()
            - 프록시 객체는 실제 엔티티 객체의 getName() 을 호출해서 결과를 반환한다
- `프록시의 특징`
  - 프록시 객체는 처음 사용할 때 `한 번만 초기화` 된다
  - 프록시 객체를 초기화 한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다
    - 프록시 객체가 초기화되면, 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다
  - 프록시 객체는 원본 엔티티를 `상속받은 객체`이므로 `타입 체크` 시에 주의해서 사용해야 한다
  - 영속성 컨텍스트에 찾는 엔티티가 이미 있으면, 데이터베이스를 조회할 필요가 없으므로 em.getReference() 를 호출해도 프록시가 아닌 `실제 엔티티`를 반환한다
  - 초기화는 `영속성 컨텍스트의 도움`을 받아야 가능하다
    - 따라서 영속성 컨텍스트의 도움을 받을 수 없는 `준영속 상태의 프록시`를 초기화하면 문제가 발생한다
    - 하이버네이트는 org.hibernate.LazyInitializationException 예외를 발생시킨다

### 1-2. 프록시와 식별자

- 엔티티를 프록시로 조회할 때 식별자(PK) 값을 파라미터로 전달하는데, 프록시 객체는 이 `식별자 값`을 `보관`한다

    ```java
    var team = em.getReference(Team.class, "team1"); // 식별자 보관
    team.getId(); // 초기화 되지 않음
    ```

- 프록시 객체는 식별자 값을 가지고 있으므로, 식별자 값을 조회하는 team.getId()를 호출해도 프록시를 초기화하지 않는다
  - 단, 엔티티 접근 방식을 프로퍼티(`@Access(AccessType.PROPERTY)`) 로 설정한 경우에만 초기화하지 않는다
  - 엔티티 접근 방식을 필드 (`@Access(AccessType.FIELD)` ) 로 설정하면 JPA는 getId() method가 id만 조회하는 method인지 다른 field까지 활용해서 어떤 일을 하는 method인지 알 수 없으므로, 프록시 객체를 초기화한다!
- 프록시는 `연관관계`를 설정할 때 유용하게 사용할 수 있다

    ```java
    var member = em.find(Member.class, "member1");
    var team = em.getReference(Team.class, "team1"); // SQL을 실행하지 않음
    member.setTeam(team);
    ```

  - 연관관계를 사용할 때는 식별자 값만 사용하므로, 프록시를 사용하면 `데이터베이스 접근 횟수` 를 줄일 수 있다
  - 참고로 연관 관계를 설정할 때는 엔티티 접근 방식을 `필드` 로 설정해도 프록시를 `초기화하지 않는다`

### 1-3. 프록시 확인

- JPA가 제공하는 PersistenceUnitUti.isLoaded(Object entity) method를 사용하면 프록시 인스턴스의 `초기화 여부`를 확인할 수 있다
  - 아직 초기화되지 않은 프록시 인스턴스는 false를 반환한다
  - 이미 초기화되었거나, 프록시 인스턴스가 아니면 true를 반환한다
- 조회된 엔티티가 진짜 엔티티인지 프록시로 조회한 것인지 확인하려면 `클래스명을 직접 출력` 해보면 된다
  - 프록시로 조회한 것이면 클래스 명 뒤에 뭔가 붙음!

### 1-4. 프록시 강제 초기화

- 하이버네이트의 `initialize()` method를 사용하면 프록시를 강제로 초기화할 수 있다
- JPA 표준에는 프록시 강제 초기화 method가 없다
  - 강제로 초기화 하려면 member.getName() 처럼 프록시의 method를 직접 호출하면 된다
  - JPA 표준은 단지 `초기화 여부` 만 확인 할 수 있다
